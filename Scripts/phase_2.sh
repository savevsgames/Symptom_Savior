# PHASE 2: Core Symptom Tracking
gh issue create --title "Create user_symptoms table in Supabase with RLS policy" --body "Description: Set up the database model for symptom tracking. In the Supabase project create a new table user_symptoms to store symptom logs. Include fields for all relevant symptom details: a primary key id UUID user_id UUID reference to auth.users symptom_description text describing the symptom severity integer 1-10 optional duration_days location text e.g. body part triggers text or text array for things that brought it on relieving_factors text associated_symptoms text array and timestamps recorded_at created_at updated_at. Implement a Row Level Security policy so that each user can only access their own symptom entries. Use Supabase policy UI or SQL: e.g. CREATE POLICY Users can only access their own symptoms ON user_symptoms FOR ALL USING auth.uid() = user_id. Enable RLS on the table. No UI changes in the app for this issue but this must be in place before the app starts reading/writing actual data. Also consider setting up an index on user_id for performance and maybe on recorded_at for ordering by date. File Paths: Not in app code this is a database setup. Document the table schema in the repo perhaps in a docs/schema.sql or Supabase migration file if using migrations. The app will reference this table via Supabase client e.g. supabase.from user_symptoms. Component Reuse: N/A backend only. Data Sources: Supabase Postgres after creation test the table by inserting a sample symptom for a user via the SQL editor or a curl request with a user token to ensure RLS works another users token should not retrieve it. Expo Router Navigation: N/A. Acceptance Criteria: 1. The user_symptoms table exists on Supabase with all required columns to capture symptom details description severity etc matching the data needs of the app. 2. RLS is enabled on this table and the policy restricts access to only the owning users rows. Verification: when the app with a users JWT queries this table it sees only that users data; unauthorized access is prevented. 3. The apps Supabase client from Phase 1 can successfully interact with this table tested in subsequent issues. 4. Table design aligns with the apps needs and the AI integration e.g. we store enough info like triggers so AI can use it later for context." --label "phase:2,backend,supabase,RLS,schema"

gh issue create --title "Implement 'Log New Symptom' form and save entry to database" --body "Description: Connect the Add Symptom screen app/add-symptom.tsx to real data operations. Currently the UI allows input of symptom name or selection from common list severity description and triggers. Modify handleSave to insert a new record into the user_symptoms table via the Supabase client. Collect all fields: use selectedSymptom or customSymptom as the main symptom name/description severity 1-5 in UI but map to 1-10 scale if needed description additional details triggers array of selected triggers join into text or store as text array if column allows. Also capture current timestamp for recorded_at Supabase can default it. Call supabase.from user_symptoms .insert with these values. Handle the promise: on success perhaps retrieve the inserted object Supabase returns it. On error alert the user. Upon successful insert navigate back to the previous screen Dashboard or Symptoms list so the new entry can be seen. Optionally show a toast or alert Symptom recorded successfully currently an Alert is used. Important: ensure the user_id is set correctly Supabase can auto-set user_id via a policy using auth.uid() on insert if configured or you must include it by reading supabase.auth.user().id. Check if RLS allows insert without specifying user likely yes if using auth.uid() in policy for insert. File Paths: app/add-symptom.tsx update the handleSave function. Also ensure router.push /add-symptom from Dashboard still works after changes. Possibly add loading state during save to prevent duplicate submissions. Component Reuse: Continue using the components in this form chips for triggers etc. If any UI improvements are needed like a better severity slider or a date picker for duration those can be future enhancements for now the focus is functionality. Data Sources: Supabase user_symptoms table from previous issue. This is where the insert goes. If any additional processing is needed like calling an API to analyze the symptom immediately that will be handled in subsequent issues vector embedding or recommendations. For now just ensure data is saved. Expo Router Navigation: After saving use router.back() as currently coded or router.push /(tabs)/symptoms to show the history. The navigation should result in the user seeing their updated symptom list or dashboard. No new routes introduced here. Acceptance Criteria: 1. Users can fill out the Log New Symptom form and tap save and the data is actually stored in Supabase. Verify by querying the database or by seeing it appear in the apps history list next issue. 2. The form performs validation: it does not allow saving if no symptom name is provided already implemented via an Alert. Also consider preventing duplicate taps on save by disabling the button while the insert is in progress. 3. On success the user is taken back to the appropriate screen and given feedback the current Alert Symptom Logged can remain or use a subtle confirmation. 4. The database entry includes correct details: the right user_id the symptom name/description severity number and any triggers listed concatenated or array as decided." --label "phase:2,frontend,supabase,expo,typescript"

gh issue create --title "Connect Symptom History screen to live data" --body "Description: Replace the static dummy data on the Symptom History screen app/(tabs)/symptoms.tsx with real data from Supabase. On component mount or using a hook fetch the current users symptom entries: supabase.from user_symptoms .select .order recorded_at ascending false. Use the Supabase client to retrieve id symptom_description severity recorded_at triggers and any other fields needed for display. Store the result in state symptoms array. Remove the hardcoded sample symptoms. Implement loading and error handling show an ActivityIndicator or text while loading and a message if fetch fails. Then implement pull-to-refresh or live update if possible: consider using Supabases onSnapshot/subscription or refetch on focus so the list updates when a new symptom is added for MVP manual refresh is acceptable. Update the filtering logic: currently it filters dummy data by text and severity. Make it filter the fetched symptoms state instead this should work just ensure field names match you might need to adjust if the fetched object uses symptom_description vs the code expecting symptom and description. Possibly map the fetched data to the components SymptomEntry type e.g. set symptom: symptom_description.split as a simple name or decide to store a separate short name field. The UI should remain similar list of symptom cards search bar filtering by symptom name or description and severity filter chips mild/moderate/severe. Ensure those filters apply to the real data e.g. severity <=2 = mild etc. File Paths: app/(tabs)/symptoms.tsx inside the component add a useEffect to fetch data manage state for symptoms initially empty/loading. Remove or adapt the useState initialization of dummy data. Also consider moving the fetch logic to a separate hook or context if needed later not necessary now. Component Reuse: Use the SymptomCard component from Phase 0 for each list item if created. Ensure styling matches design. The search input and filter chips remain as is just now filtering the real list. Data Sources: Supabase user_symptoms table. Only the current users data will be fetched RLS ensures that. The query should include all fields needed for display: e.g. symptom_description for both title and detail if needed severity maybe triggers and recorded_at to display date/time in place of the dummy Today / 2:30 PM which was static. You might need to format the timestamp into a relative day/time string. Expo Router Navigation: The View All link on Dashboard pushes to /symptoms ensure this still works and now shows actual data. When a symptom entry is tapped we will navigate to a detail screen next issue. For now it might do nothing thats okay until detail is implemented. Acceptance Criteria: 1. When the user opens the Symptom History tab they see a list of their logged symptoms pulled from the database or No symptoms found state if none. The data matches what was input via the Log form. 2. The search bar and filter buttons properly filter the list of symptoms. E.g. typing head filters to entries whose name or description contains head; tapping Severe filter shows only severity >=4. 3. Performance is acceptable for the list likely small data sets for now. 4. The UI reacts to new entries: if the user adds a symptom and returns to this screen the new symptom is visible either automatically or after a refresh. No stale dummy data remains." --label "phase:2,frontend,supabase,expo,typescript"

gh issue create --title "Build Symptom Detail view for logged entries" --body "Description: Create a screen to display detailed information about a single symptom log entry. When a user taps on an item in the Symptoms list navigate to a detail page that shows all fields of that entry. For example Symptom Detail screen app/symptoms/[id].tsx that reads the id from the route params and fetches that record or pass the data through navigation to avoid another fetch. Display the symptom name date/time recorded severity maybe as a colored badge or number description triggers and any associated symptoms or notes. The design can be simple: perhaps reuse the card style for layout or a scrollable view with sections Symptom Details Triggers etc. Include a back button in the header Expo Router will show one by default if using a Stack screen. Also if needed allow deletion or editing from this screen: perhaps a trash icon to delete the log confirmation required this is optional for MVP but mention if time permits. File Paths: Create app/(tabs)/symptoms/[id].tsx as a new route since symptoms.tsx is in tabs we might need to nest a folder: e.g. app/(tabs)/symptoms/_layout.tsx and app/(tabs)/symptoms/[id].tsx moving the list to index.tsx. Alternatively put the detail screen at root app/symptom/[id].tsx and push to that. Choose an approach that integrates well: likely nesting within symptoms/ folder so it keeps the bottom tab visible or at least is logically grouped. Fetching can be done via supabase.from user_symptoms .select .eq id routeParam or easier: pass the selected symptom object via router Expo Router supports passing params but objects might need to be serialized so safer to just fetch by id. Component Reuse: Use SymptomCard in large form or reuse some styling from it for consistency. Use BaseText components for labels. If triggers list exists reuse a chip style from Add Symptom screen to display them. Data Sources: Supabase user_symptoms. Only one row is fetched by id RLS will ensure user owns it. Expo Router Navigation: Tapping a symptom in the list should call router.push /(tabs)/symptoms/[id] params or similar. The detail screen should show a back arrow Stack navigation to go back to list. Ensure the route is correctly registered. After deletion if implemented navigate back to list and update state could remove from list. Acceptance Criteria: 1. Tapping on a symptom entry opens a detail view that shows all information recorded for that symptom name severity date full description triggers etc. 2. The detail view is well-formatted and easy to read for example date/time is shown in a user-friendly format triggers are maybe shown as a list of tags. 3. Optional A user can delete the symptom log from this screen. If implemented the entry is removed from Supabase and the list screen is refreshed upon going back. Deletion is confirmed to avoid accidents. 4. The navigation experience is smooth: back button returns to the list which still has scroll position or updated list and no memory leaks occur from any detail fetch." --label "phase:2,frontend,expo,typescript"

gh issue create --title "Build Symptom Detail view for logged entries" --body "Description: Create a screen to display detailed information about a single symptom log entry. When a user taps on an item in the Symptoms list navigate to a detail page that shows all fields of that entry. For example Symptom Detail screen app/symptoms/[id].tsx that reads the id from the route params and fetches that record or pass the data through navigation to avoid another fetch. Display the symptom name date/time recorded severity maybe as a colored badge or number description triggers and any associated symptoms or notes. The design can be simple: perhaps reuse the card style for layout or a scrollable view with sections Symptom Details Triggers etc. Include a back button in the header Expo Router will show one by default if using a Stack screen. Also if needed allow deletion or editing from this screen: perhaps a trash icon to delete the log confirmation required this is optional for MVP but mention if time permits. File Paths: Create app/(tabs)/symptoms/[id].tsx as a new route since symptoms.tsx is in tabs we might need to nest a folder: e.g. app/(tabs)/symptoms/_layout.tsx and app/(tabs)/symptoms/[id].tsx moving the list to index.tsx. Alternatively put the detail screen at root app/symptom/[id].tsx and push to that. Choose an approach that integrates well: likely nesting within symptoms/ folder so it keeps the bottom tab visible or at least is logically grouped. Fetching can be done via supabase.from user_symptoms .select .eq id routeParam or easier: pass the selected symptom object via router Expo Router supports passing params but objects might need to be serialized so safer to just fetch by id. Component Reuse: Use SymptomCard in large form or reuse some styling from it for consistency. Use BaseText components for labels. If triggers list exists reuse a chip style from Add Symptom screen to display them. Data Sources: Supabase user_symptoms. Only one row is fetched by id RLS will ensure user owns it. Expo Router Navigation: Tapping a symptom in the list should call router.push /(tabs)/symptoms/[id] params or similar. The detail screen should show a back arrow Stack navigation to go back to list. Ensure the route is correctly registered. After deletion if implemented navigate back to list and update state could remove from list. Acceptance Criteria: 1. Tapping on a symptom entry opens a detail view that shows all information recorded for that symptom name severity date full description triggers etc. 2. The detail view is well-formatted and easy to read for example date/time is shown in a user-friendly format triggers are maybe shown as a list of tags. 3. Optional A user can delete the symptom log from this screen. If implemented the entry is removed from Supabase and the list screen is refreshed upon going back. Deletion is confirmed to avoid accidents. 4. The navigation experience is smooth: back button returns to the list which still has scroll position or updated list and no memory leaks occur from any detail fetch." --label "phase:2,frontend,expo,typescript"

# CREATED - JUNE 19 - 2025
# Creating issue in savevsgames/Symptom_Savior
# https://github.com/savevsgames/Symptom_Savior/issues/8
# Creating issue in savevsgames/Symptom_Savior
# https://github.com/savevsgames/Symptom_Savior/issues/9
# Creating issue in savevsgames/Symptom_Savior
# https://github.com/savevsgames/Symptom_Savior/issues/10
# Creating issue in savevsgames/Symptom_Savior
# https://github.com/savevsgames/Symptom_Savior/issues/11
# Creating issue in savevsgames/Symptom_Savior
# https://github.com/savevsgames/Symptom_Savior/issues/12